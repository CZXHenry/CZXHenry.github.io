<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Henry Chan | </title>
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/markdown.css">
    <link rel="stylesheet" href="/css/fonts.css">
</head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Henry Chan</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            [Envoy学习笔记]（八）建立连接、处理数据和转发流量
        </div>
        <div class="post-meta">
            2019-01-01
        </div>
    

    <div class="post-md">
        <blockquote>
<p>浪了两三天，终于又下定决心开始写Envoy分析博客了。写这些博客的很重要的一个原因就是希望能够帮助我自己更加理解Envoy的各种机制，所以难点不在于把博客写出来而是怎么去理解这些东西。看Envoy的源码是我第一次看源码，所以非常的头大，逃避心理也很严重，但是我应该可以坚持下去的，毕竟这是毕设hhhh</p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li>前一篇博客主要是关于Listener的总结。而这一篇主要就是基于参考链接中的两篇博客，对Envoy处理Http请求的进一步解析。其实这个Http请求到响应的全链路主要是可以分成三大部分的，分别是建立连接、处理数据和转发流量。接下来就会分别对这三个部分的代码进行分析总结。<h2 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h2></li>
<li>前面已经说过怎么注册事件，使Socket监听连接请求，当新的连接请求到来时，会自动调用已经注册好的回调函数。</li>
<li><p><strong>connection_handler_impl.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> ConnectionHandlerImpl::ActiveSocket::continueFilterChain(<span class="keyword">bool</span> success) &#123;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter_ == accept_filters_.end()) &#123;</span><br><span class="line">      iter_ = accept_filters_.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter_ = <span class="built_in">std</span>::next(iter_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; iter_ != accept_filters_.end(); iter_++) &#123;</span><br><span class="line">      Network::FilterStatus status = (*iter_)-&gt;onAccept(*<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (status == Network::FilterStatus::StopIteration) &#123;</span><br><span class="line">        <span class="comment">// The filter is responsible for calling us again at a later time to continue the filter</span></span><br><span class="line">        <span class="comment">// chain from the next filter.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Successfully ran all the accept filters.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the socket may need to be redirected to another listener.</span></span><br><span class="line">    ActiveListener* new_listener = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hand_off_restored_destination_connections_ &amp;&amp; socket_-&gt;localAddressRestored()) &#123;</span><br><span class="line">      <span class="comment">// Find a listener associated with the original destination address.</span></span><br><span class="line">      new_listener = listener_.parent_.findActiveListenerByAddress(*socket_-&gt;localAddress());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (new_listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Hands off connections redirected by iptables to the listener associated with the</span></span><br><span class="line">      <span class="comment">// original destination address. Pass 'hand_off_restored_destionations' as false to</span></span><br><span class="line">      <span class="comment">// prevent further redirection.</span></span><br><span class="line">      new_listener-&gt;onAccept(<span class="built_in">std</span>::move(socket_), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Set default transport protocol if none of the listener filters did it.</span></span><br><span class="line">      <span class="keyword">if</span> (socket_-&gt;detectedTransportProtocol().empty()) &#123;</span><br><span class="line">        socket_-&gt;setDetectedTransportProtocol(</span><br><span class="line">            Extensions::TransportSockets::TransportSocketNames::get().RawBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Create a new connection on this listener.</span></span><br><span class="line">      <span class="comment">// 创建一个新的连接</span></span><br><span class="line">      listener_.newConnection(<span class="built_in">std</span>::move(socket_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> ConnectionHandlerImpl::ActiveListener::onAccept(</span><br><span class="line">    Network::ConnectionSocketPtr&amp;&amp; socket, <span class="keyword">bool</span> hand_off_restored_destination_connections) &#123;</span><br><span class="line">  <span class="keyword">auto</span> active_socket = <span class="built_in">std</span>::make_unique&lt;ActiveSocket&gt;(*<span class="keyword">this</span>, <span class="built_in">std</span>::move(socket),</span><br><span class="line">                                                      hand_off_restored_destination_connections);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and run the filters</span></span><br><span class="line">  config_.filterChainFactory().createListenerFilterChain(*active_socket);</span><br><span class="line">  active_socket-&gt;continueFilterChain(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move active_socket to the sockets_ list if filter iteration needs to continue later.</span></span><br><span class="line">  <span class="comment">// Otherwise we let active_socket be destructed when it goes out of scope.</span></span><br><span class="line">  <span class="keyword">if</span> (active_socket-&gt;iter_ != active_socket-&gt;accept_filters_.end()) &#123;</span><br><span class="line">    active_socket-&gt;startTimer();</span><br><span class="line">    active_socket-&gt;moveIntoListBack(<span class="built_in">std</span>::move(active_socket), sockets_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当连接请求到来时被调用的函数就是OnAccept函数,这里会创建一系列的Filter并且运行</li>
<li>continueFilterChain函数中运行全部的Filter，并且会创建ConnectionImpl类对象，这个类是对连接的一个抽象，连接创建之后的各种事件注册都是由这个对象负责的。</li>
<li>newConnection函数中创建了一个ConnectionImpl类对象</li>
</ul>
</li>
<li><p><strong>connection_impl.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ConnectionImpl::ConnectionImpl(Event::Dispatcher&amp; dispatcher, ConnectionSocketPtr&amp;&amp; socket,</span><br><span class="line">                               TransportSocketPtr&amp;&amp; transport_socket, <span class="keyword">bool</span> connected)</span><br><span class="line">    : transport_socket_(<span class="built_in">std</span>::move(transport_socket)), socket_(<span class="built_in">std</span>::move(socket)),</span><br><span class="line">      filter_manager_(*<span class="keyword">this</span>, *<span class="keyword">this</span>), stream_info_(dispatcher.timeSystem()),</span><br><span class="line">      write_buffer_(</span><br><span class="line">          dispatcher.getWatermarkFactory().create([<span class="keyword">this</span>]() -&gt; <span class="keyword">void</span> &#123; <span class="keyword">this</span>-&gt;onLowWatermark(); &#125;,</span><br><span class="line">                                                  [<span class="keyword">this</span>]() -&gt; <span class="keyword">void</span> &#123; <span class="keyword">this</span>-&gt;onHighWatermark(); &#125;)),</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// We never ask for both early close and read at the same time. If we are reading, we want to</span></span><br><span class="line">  <span class="comment">// consume all available data.</span></span><br><span class="line">  <span class="comment">// 注册文件读写事件，回调函数实际上就是onFileEvent函数</span></span><br><span class="line">  file_event_ = dispatcher_.createFileEvent(</span><br><span class="line">      fd(), [<span class="keyword">this</span>](<span class="keyword">uint32_t</span> events) -&gt; <span class="keyword">void</span> &#123; onFileEvent(events); &#125;, Event::FileTriggerType::Edge,</span><br><span class="line">      Event::FileReadyType::Read | Event::FileReadyType::Write);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConnectionImpl的类构造函数会注册文件读写事件，当事件到来的时候就调用onFileEvent</li>
<li>在OnFileEvent函数中会判断具体是什么事件触发的这个函数，然后根据不同事件调用不同的函数。比如读事件就调用onReadReady函数，写事件就调用onWriteReady函数</li>
<li>在onReadReady函数中，调用doRead函数进行真正的数据读取，将数据读取到Connection的read_buffer_中。读取完之后再根据读取的结果做进一步的操作。当确定读取到有数据时，则会继续调用onRead对数据作进一步处理；如果连接已经被客户关闭且没有多余的数据要处理则关闭Socket</li>
<li>onWriteReady函数也跟onReadReady函数差不多，都是调用了另外一个doWrite函数去完成真实的写操作。然后再根据写入的结果来确定下一步的操作<br>到此一个连接已经完全建立了，注册了读写函数，会在接收到读写事件之后自动调用各种处理流程，下一步就如何处理接收到的流量了<h2 id="3-处理流量"><a href="#3-处理流量" class="headerlink" title="3. 处理流量"></a>3. 处理流量</h2></li>
</ul>
</li>
<li>Envoy包含了很多的对流量的处理，比如限流、熔断等。在这里就是对流量进行各种的处理，处理之后再将数据转发到上游的机器中去</li>
<li><p><strong>connection_impl.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> ConnectionImpl::onRead(<span class="keyword">uint64_t</span> read_buffer_size) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!read_enabled_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_buffer_size == <span class="number">0</span> &amp;&amp; !read_end_stream_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_end_stream_) &#123;</span><br><span class="line">    <span class="comment">// read() on a raw socket will repeatedly return 0 (EOF) once EOF has</span></span><br><span class="line">    <span class="comment">// occurred, so filter out the repeats so that filters don't have</span></span><br><span class="line">    <span class="comment">// to handle repeats.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// I don't know of any cases where this actually happens (we should stop</span></span><br><span class="line">    <span class="comment">// reading the socket after EOF), but this check guards against any bugs</span></span><br><span class="line">    <span class="comment">// in ConnectionImpl or strangeness in the OS events (epoll, kqueue, etc)</span></span><br><span class="line">    <span class="comment">// and maintains the guarantee for filters.</span></span><br><span class="line">    <span class="keyword">if</span> (read_end_stream_raised_) &#123;</span><br><span class="line">      <span class="comment">// No further data can be delivered after end_stream</span></span><br><span class="line">      ASSERT(read_buffer_size == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read_end_stream_raised_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter_manager_.onRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>onRead函数大部分就是判断是否有读到了数据之类的，真正的对数据处理又是调用了filter_manager_.onRead()</li>
</ul>
</li>
<li><p><strong>filter_manager_impl.cc</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> FilterManagerImpl::onContinueReading(ActiveReadFilter* filter) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;ActiveReadFilterPtr&gt;::iterator entry;</span><br><span class="line">  <span class="comment">// 如果传入的filter为空，表明从最开始的filter开始进行遍历</span></span><br><span class="line">  <span class="keyword">if</span> (!filter) &#123;</span><br><span class="line">    entry = upstream_filters_.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    entry = <span class="built_in">std</span>::next(filter-&gt;entry());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; entry != upstream_filters_.end(); entry++) &#123;</span><br><span class="line">    <span class="comment">// 检测filter是不是在该链接中第一次被用到</span></span><br><span class="line">    <span class="comment">// 如果是第一次被用到则需要调用onNewConnection来初试化</span></span><br><span class="line">    <span class="keyword">if</span> (!(*entry)-&gt;initialized_) &#123;</span><br><span class="line">      (*entry)-&gt;initialized_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 第一次访问则调用onNewConnection</span></span><br><span class="line">      FilterStatus status = (*entry)-&gt;filter_-&gt;onNewConnection();</span><br><span class="line">      <span class="keyword">if</span> (status == FilterStatus::StopIteration) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里才是filter真正发挥作用的地方</span></span><br><span class="line">    BufferSource::StreamBuffer read_buffer = buffer_source_.getReadBuffer();</span><br><span class="line">    <span class="keyword">if</span> (read_buffer.buffer.length() &gt; <span class="number">0</span> || read_buffer.end_stream) &#123;</span><br><span class="line">      <span class="comment">// 后续调用onData</span></span><br><span class="line">      FilterStatus status = (*entry)-&gt;filter_-&gt;onData(read_buffer.buffer, read_buffer.end_stream);</span><br><span class="line">      <span class="keyword">if</span> (status == FilterStatus::StopIteration) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FilterManagerImpl::onRead() &#123;</span><br><span class="line">  ASSERT(!upstream_filters_.empty());</span><br><span class="line">  onContinueReading(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为每个Listener可以配置一系列的Filter，即Filter Chain。我认为这个onContinueFilterChain函数是被设定为可以从Filter Chain中某一个Filter开始读取的。如果传入onContinueFilterChain的参数为nullptr则表明从Filter Chain的第一个filter开始</li>
<li>Envoy只定义了几个可用的Filter，下面就以最常用的envoy.http_connection_manager为例进行分析。这个filter的实现就是ConnectionManagerImpl</li>
</ul>
</li>
<li><p><strong>conn_manager_impl.h</strong></p>
<ul>
<li><p>ConnectionManagerImpl类继承了ReadFilter，实现了onData中的具体工作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance&amp; data, <span class="keyword">bool</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!codec_) &#123;</span><br><span class="line">    codec_ = config_.createCodec(read_callbacks_-&gt;connection(), data, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (codec_-&gt;protocol() == Protocol::Http2) &#123;</span><br><span class="line">      stats_.named_.downstream_cx_http2_total_.inc();</span><br><span class="line">      stats_.named_.downstream_cx_http2_active_.inc();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stats_.named_.downstream_cx_http1_total_.inc();</span><br><span class="line">      stats_.named_.downstream_cx_http1_active_.inc();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> redispatch;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    redispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codec_-&gt;dispatch(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> CodecProtocolException&amp; e) &#123;</span><br><span class="line">      <span class="comment">// HTTP/1.1 codec has already sent a 400 response if possible. HTTP/2 codec has already sent</span></span><br><span class="line">      <span class="comment">// GOAWAY.</span></span><br><span class="line">      ENVOY_CONN_LOG(debug, <span class="string">"dispatch error: &#123;&#125;"</span>, read_callbacks_-&gt;connection(), e.what());</span><br><span class="line">      stats_.named_.downstream_cx_protocol_error_.inc();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In the protocol error case, we need to reset all streams now. Since we do a flush write and</span></span><br><span class="line">      <span class="comment">// delayed close, the connection might stick around long enough for a pending stream to come</span></span><br><span class="line">      <span class="comment">// back and try to encode.</span></span><br><span class="line">      resetAllStreams();</span><br><span class="line"></span><br><span class="line">      read_callbacks_-&gt;connection().close(Network::ConnectionCloseType::FlushWriteAndDelay);</span><br><span class="line">      <span class="keyword">return</span> Network::FilterStatus::StopIteration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Processing incoming data may release outbound data so check for closure here as well.</span></span><br><span class="line">    checkForDeferredClose();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The HTTP/1 codec will pause dispatch after a single message is complete. We want to</span></span><br><span class="line">    <span class="comment">// either redispatch if there are no streams and we have more data. If we have a single</span></span><br><span class="line">    <span class="comment">// complete non-WebSocket stream but have not responded yet we will pause socket reads</span></span><br><span class="line">    <span class="comment">// to apply back pressure.</span></span><br><span class="line">    <span class="keyword">if</span> (codec_-&gt;protocol() != Protocol::Http2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (read_callbacks_-&gt;connection().state() == Network::Connection::State::Open &amp;&amp;</span><br><span class="line">          data.length() &gt; <span class="number">0</span> &amp;&amp; streams_.empty()) &#123;</span><br><span class="line">        redispatch = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!streams_.empty() &amp;&amp; streams_.front()-&gt;state_.remote_complete_) &#123;</span><br><span class="line">        read_callbacks_-&gt;connection().readDisable(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (redispatch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里有点疑问，为什么不返回FilterStatus::StopIteration</span></span><br><span class="line">  <span class="comment">// 这样是不是就表明HTTPConnectionFilter只能放在FilterChain的最后</span></span><br><span class="line">  <span class="keyword">return</span> Network::FilterStatus::StopIteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真正的解码就在dispatchSlice中完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">size_t</span> ConnectionImpl::dispatchSlice(<span class="keyword">const</span> <span class="keyword">char</span>* slice, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> rc = http_parser_execute(&amp;parser_, &amp;settings_, slice, len);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里是使用了http_parser这个库来对http包进行解析。ConnectionImpl类中声明了一个http_parser_settings类型的settings对象，这个对象设定了解析http包每个部分应该使用的回调函数。当http包到达envoy时，就会自动调用设定好的回调函数去解析对应的部分，而在解析完http请求行、请求头之后就会确定应该将数据转发到集群中的哪一个host。</p>
<h2 id="4-请求转发"><a href="#4-请求转发" class="headerlink" title="4. 请求转发"></a>4. 请求转发</h2><p>Envoy的请求转发是在http_parser库处理完http包的请求行和请求头之后进行调用的，通过url判断出应该转发到哪个进群，然后通过负载均衡算法选出目的主机，最后从连接池中选出可用连接，跟选出来的host建立连接，最后发送请求。更加详细的解析可以看<a href="https://blog.csdn.net/surlymo/article/details/82387314" target="_blank" rel="noopener">这个博客</a></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总结一下一个http连接建立的过程大致就是：</p>
</li>
</ul>
</li>
<li>与下游主机建立连接</li>
<li>读取下游主机发送过来的数据</li>
<li>遍历Filter，对数据进行处理（下面就以ConnectionManager这个filter作为例子）<ul>
<li>调用http_parser库对数据进行解析<ul>
<li>解析完URL和头信息之后就进行再一次的filter过滤（下面就以Route::Filter作为例子）<ul>
<li>确定集群</li>
<li>负载均衡，确定发送到的主机</li>
<li>从连接池中取出与主机对应的连接</li>
<li>建立连接，发送数据<h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6. 参考链接"></a>6. 参考链接</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/surlymo/article/details/82350106" target="_blank" rel="noopener">【Servicemesh系列】【Envoy源码解析（二）】一个Http请求到响应的全链路（一）</a></li>
<li><a href="https://blog.csdn.net/surlymo/article/details/82387314" target="_blank" rel="noopener">【Servicemesh系列】【Envoy源码解析（三）】一个Http请求到响应的全链路（二）</a></li>
<li><a href="https://www.cnblogs.com/arnoldlu/p/6497837.html" target="_blank" rel="noopener">开源HTTP解析器—http-parser和fast-http</a></li>
<li><a href="https://github.com/nodejs/http-parser" target="_blank" rel="noopener">Github http-parser</a></li>
</ul>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 Henry Chan</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>

<link rel="stylesheet" href="/css/a11y-dark.min.css">
<script src="/js/highlight.min.js"></script>
<script src="/js/highlightjs-line-numbers.js"></script>

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>